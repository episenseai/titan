from datetime import datetime
from typing import Optional
from uuid import uuid4

from databases import Database
from pydantic import UUID4

from ..exceptions import DatabaseUserFetchError
from ..models import ImmutBaseModel
from ..oauth2.models import IdP, OAuth2AuthentcatedUser
from .schema import users_schema

# from passlib.context import CryptContext

# ["auto"] will configure the CryptContext instance to deprecate all
# supported schemes except for the default scheme.
# pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto", truncate_error=True)


# connect with database on app startup and disconnect on shutdown
database = Database("postgresql://localhost/testdb")
users_table = users_schema(table_name="users")


class UserInDB(ImmutBaseModel):
    # Unique uuid4 generated by the database.
    guid: UUID4
    # We create the account only when email is verified on the oauth2
    # provider side.
    email: str
    # given_name + family_name
    full_name: Optional[str] = None
    # Account is disabled or not.
    disabled: bool = False
    # Did we verify the email ourselves. We are creating accounts
    # ony when the email is verified by the provider.
    email_verified: bool = False
    # Granted oauth2 `scope` to the user on our platform.
    scope: str = ""
    # profile picture if available.
    picture: Optional[str] = None
    # Date of account creation on our platform.
    created_at: datetime
    # Date the account info was last updated on our platform.
    updated_at: datetime
    # Identity Provider.
    idp: IdP
    # Unique Id of the the user that we get from identity provider.
    idp_guid: str
    # Optional username/login of the user from identity provider.
    idp_username: Optional[str] = None

    class Config:
        orm_mode = True


async def get_user(email: str) -> Optional[UserInDB]:
    query = users_table.select().where(
        users_table.columns.email == email,
    )
    # returns None if the user if not in db
    user = await database.fetch_one(query=query)

    if user is not None:
        try:
            return UserInDB(**user)
        except Exception as exc:
            print(f"Can convert {user=} for {email=}")
            raise DatabaseUserFetchError from exc
    return None


async def create_user(user: OAuth2AuthentcatedUser, disabled: bool = False, email_verified: bool = False):
    basic_scope = "episense:demo"
    query = users_table.insert()
    values = user.dict(
        include={
            "email",
            "full_name",
            "picture",
            "idp",
            "idp_guid",
            "idp_username",
        },
    )
    values.update(
        {
            "disabled": disabled,
            "email_verified": email_verified,
            "scope": basic_scope,
        }
    )
    await database.execute(query=query, values=values)


async def update_user():
    pass


"""
if __name__ == "__main__":
    async def insert():
        user_dict = {
            "email": "test55@example.com",
            "full_name": "Test User",
            "picture": "https://google.com",
            "idp": "google",
            "idp_guid": "q6cg67fcq2gcuqg",
        }
        async with database as database:
            user = OAuth2AuthentcatedUser(**user_dict)
            await create_user(user=user)

    async def get():
        async with database as database:
            user = await get_user(email="test55@example.com")
            from devtools import debug

            debug(user)

    import asyncio

    asyncio.get_event_loop().run_until_complete(get())
"""


class UserDB:
    def __init__(self):
        self.db = {}

    def get(self, auth_user: OAuth2AuthentcatedUser) -> UserInDB:
        return self.db.get((auth_user.provider_id, auth_user.idp), None)

    def create_user(self, auth_user: OAuth2AuthentcatedUser) -> UserInDB:
        uuid = uuid4()
        current_datettime = datetime.utcnow()
        default_scope = "episense:demo"

        user = UserInDB(
            **auth_user.dict(),
            uuid=uuid,
            disabled=False,
            scope=default_scope,
            created_at=current_datettime,
            updated_at=current_datettime,
            email_verified=False,
        )
        self.db[(auth_user.provider_id, auth_user.idp)] = user
        return user
