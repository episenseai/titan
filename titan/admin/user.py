from datetime import datetime
from typing import Optional

from databases import Database
from pydantic import UUID4

from ..exceptions import DatabaseUserFetchError
from ..models import ImmutBaseModel
from .schema import admins_schema
from ..settings import ADMINS_DB_URL, ADMINS_TABLE_NAME

# from passlib.context import CryptContext

# ["auto"] will configure the CryptContext instance to deprecate all
# supported schemes except for the default scheme.
# pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto", truncate_error=True)


# connect with database on app startup and disconnect on shutdown
database = Database(ADMINS_DB_URL)
admins_table = admins_schema(table_name=ADMINS_TABLE_NAME)


class AdminInDB(ImmutBaseModel):
    """
    (email + username) constitutes the primary key.
    """

    # Unique uuid4 generated by the database.
    guid: UUID4
    # email id of the admin (email must exist in 'users` table)
    email: str
    # admin username
    username: str
    # admin password
    password: str
    # Account is disabled or not.
    disabled: bool
    # Granted oauth2 `scope` to the user on our platform.
    scope: str = ""
    # Date of account creation.
    created_at: datetime

    class Config:
        orm_mode = True


async def get_admin(email: str, username: str) -> Optional[AdminInDB]:
    query = (
        admins_table.select()
        .where(
            admins_table.columns.email == email,
        )
        .where(
            admins_table.columns.username == username,
        )
    )
    # returns None if the admin is not in DB
    admin = await database.fetch_one(query=query)

    if admin is not None:
        try:
            return AdminInDB(**admin)
        except Exception as exc:
            print(f"Error {admin=} for {email=} {username=}")
            raise DatabaseUserFetchError from exc
    return None
